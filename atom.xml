<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>这世界很酷K</title>
  
  <subtitle>我奔涌的暖流，寻找你的海洋</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-10T06:49:05.742Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>酷K</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博文公园(Web随心记6)</title>
    <link href="http://yoursite.com/2017/09/10/Web%E9%9A%8F%E5%BF%83%E8%AE%B06/"/>
    <id>http://yoursite.com/2017/09/10/Web随心记6/</id>
    <published>2017-09-10T05:57:30.892Z</published>
    <updated>2017-09-10T06:49:05.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Angular、vue、react-数据双向绑定的原理"><a href="#Angular、vue、react-数据双向绑定的原理" class="headerlink" title="Angular、vue、react 数据双向绑定的原理"></a>Angular、vue、react 数据双向绑定的原理</h2><p>AngularJS 采用“脏值检测”的方式，数据发生变更后，对于所有的数据和视图的绑定关系进行一次检测，识别是否有数据发生了改变，有变化进行处理，可能进一步引发其他数据的改变，<br>所以这个过程可能会循环 几次，一直到不再有数据变化发生后，将变更的数据发送到视图，更新页面展现。如果是手动对 ViewModel 的数据进行变更，为确保变更同步到视图，需要手动<br>触发一次“脏值检测”。</p><p>VueJS 则使用 ES5 提供的 Object.defineProperty() 方法，监控对数据的操作，从而可以自动触发数据同步。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，<br>而不是对所有的数据都执行一次检测。</p><p>React数据绑定<br>React采用这种方式，考虑虚拟DOM树的更新：<br>属性更新，组件自己处理<br>结构更新，重新“渲染”子树（虚拟DOM），找出最小改动步骤，打包DOM操作，给真实DOM树打补丁<br>单纯从数据绑定来看，React虚拟DOM没有数据绑定，因为setState()不维护上一个状态（状态丢弃），谈不上绑定<br>从数据更新机制来看，react类似于提供数据模型的方式（必须通过state更新）<br>没有双向数据绑定的话，input的双向场景要怎么实现？通过框架提供的API，手动通知数据变化，和操作DOM的方式很像</p><h2 id="ES6新特性："><a href="#ES6新特性：" class="headerlink" title="ES6新特性："></a>ES6新特性：</h2><p>块级作用域<br>Let关键词，声明一个变量<br>Const关键词，声明一个常量<br>变量的解构赋值 数组解构赋值，对象的解构赋值<br>字符串扩展 Includes、检测是否包含某个字符<br>startWith、可以判断是否以某个字符开始<br>endWith、可以判断是否以某个字符结束<br>repeat、  可以重复某个字符<br>padStart/endStart可以字符串补全 Nodejs现在还不支持<br>反引号  `  定义字符串<br>数组扩展  Array.from();伪数组转数组<br>Array.of()创建数组<br>Arr.find() 发现并返回符合条件的第一个元素<br>arr.findIndex()发现并返回符合条件的第一个元素的索引值<br>函数扩展<br>箭头函数  使用“箭头”(=&gt;) 定义函数</p><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs:"></a>Nodejs:</h2><p>Nodejs则是需要通过命令行工具以命令的形式执行。<br>Nodejs是一种运行环境<br>Nodejs是一个基于Chrome V8引擎的 JavaScript运行环境，其使用了一个事件驱动、非阻塞式I/O的模型，使其轻量又高效<br>Nodejs是一个后端开发环境<br>Nodejs需要通过命令行工具以命令的形式执行<br>宿主环境不同，依据ECMAScript标准实现的脚本的执行方式也不同，例如JavaScript必须通过script标签引入，才能在浏览器环境执行，Nodejs则需要通过命令行工具以命令的形式执行</p><p>Nodejs在ECMAScript的基础上扩展并封装了许多高级特性，使得Nodejs称为一个很好的Web开发平台<br>基于Nodejs这个平台将Web开发常用的一些功能进行封装，称为模块<br>（将一堆功能封装起来，供开发者调用，称为模块）<br>1.系统模块：<br>os模块–获取当前操作系统信息<br>fs模块–文件读取和操作<br>path模块–路径处理<br>http模块–创建并启动http服务器<br>文件模块：用户模块+第三方模块</p><p>2.Express框架：<br>使用Nodejs可以非常迅速的搭建服务器，而在真正的开发中，一般都会用框架进行开发，express框架是Nodejs中非常流行的框架之一；<br>Express是一个简洁而灵活的node.js web应用框架，提供了一系列强大的特性帮助我们创建各种web应用和丰富的http工具<br>Express框架的核心特性：<br>（1）可以设置中间件来响应http请求<br>（2）定义路由表执行不同的http请求动作<br>（3）可以用模板传递参数来动态渲染HTML页面</p><p>3.路由：<br>是指URL地址与程序的映射关系，改变URL地址可以改变程序的执行结果</p><h2 id="Express中处理请求数据格式："><a href="#Express中处理请求数据格式：" class="headerlink" title="Express中处理请求数据格式："></a>Express中处理请求数据格式：</h2><p>（1）get方式请求的参数：使用req.params/req.query接收<br>Req.params接收的参数是通过路由定义的形参 ：<br>Req.query接收的参数是地址?后面部分<br>（2）post方式请求的参数通过req.body接收；<br>必须使用中间件（body-parse）后才能使用</p><h2 id="中间件："><a href="#中间件：" class="headerlink" title="中间件："></a>中间件：</h2><p>Express将请求和响应的过程划分成多个阶段，任何一个阶段都允许调用一个函数来对请求或响应做出修改，这个函数就是中间件，express使用use方法调用中间件，中间件是按照顺序执行的。<br>中间件一般用来操作请求和响应<br><a href="http://www.cnblogs.com/lianer/p/5178693.html" target="_blank" rel="external">http://www.cnblogs.com/lianer/p/5178693.html</a><br>body-parse：<br>bodyParse中间件用来解析http请求，是express默认使用的中间件之一<br>const bodyParse = require(“body-parse”);<br>//负责解析post请求过来的数据，然后将解析的结果赋值给req.body.<br>App.use(bodyParse.urlencoded({extended:false}));<br>App.post(“/”,(req, res) =&gt; {console.log(req.body)})<br>app.use(bodyParser.json());<br>app.use(bodyParser.urlencoded({ extended: false }));<br>顾名思义，bodyParser.json是用来解析json数据格式的。bodyParser.urlencoded则是用来解析我们通常的form表单提交的数据，也就是请求头中包含这样的信息：<br>Content-Type: application/x-www-form-urlencoded<br>bodyParser.urlencoded 模块用于解析req.body的数据，解析成功后覆盖原来的req.body，如果解析失败则为 {}。该模块有一个属性extended，官方介绍如下：<br>Extended()允许配置使用querystring（false）或qs（true）<br>Querystring是Nodejs内置对象之一，用来字符串化对象或解析字符串<br>querystring.parse(“name=henry&amp;age=30”) =&gt; { name: ‘henry’, age: ‘30’ }<br>Qs是一个querystring库，在qs中，支持了更多功能并优化了一些安全性；<br>Querystring不能解析复杂的对象，而qs可以做到</p><p>npm:<br>Node Package Manager<br>Npm/svn是Nodejs官方提供的一个专门用于管理第三方模块的工具，这个工具随着Nodejs一起被安装，使用npm/svn可以安装、卸载、发布模块</p><h2 id="JS创建对象的三种方式："><a href="#JS创建对象的三种方式：" class="headerlink" title="JS创建对象的三种方式："></a>JS创建对象的三种方式：</h2><p>（1）使用内置对象：<br>JavaScript可用的内置对象可分为两种：<br>1，JavaScript语言原生对象（语言级对象），如String、Object、Function等；<br>2，JavaScript运行期的宿主对象（环境宿主级对象），如window、document、body等。<br>Var obj = new String()<br>Var obj = new Function();<br>Var obj = new Object();<br>Obj.name = “lisi”;<br>Obj.age = 18;</p><p>（2）使用JSON语句<br>Var a = {“name”: “lisi”, “age”: “18”};</p><p>（3）使用构造函数实例化<br>Function Fn(){<br>This.name = ‘lisi’;<br>This.say = function(){};<br>};</p><h1 id="JS的数据类型：基本类型-引用类型"><a href="#JS的数据类型：基本类型-引用类型" class="headerlink" title="JS的数据类型：基本类型+引用类型"></a>JS的数据类型：基本类型+引用类型</h1><h2 id="基本类型（5）-引用类型"><a href="#基本类型（5）-引用类型" class="headerlink" title="基本类型（5） 引用类型"></a>基本类型（5） 引用类型</h2><p>Null undefined boolean string number  js中除了基本类型就是引用类型了，也可以说就是对象了<br>Number String Boolean Function Object Math Date  Array Error<br>基本类型的值不可变 引用类型的值可变<br>基本类型的数据不可以添加属性和方法 引用类型可以拥有属性和方法，且可以动态改变<br>基本类型比较的是值比较 引用类型的比较是地址的比较<br>基本类型的变量存放在栈中  引用类型的值同时保存在堆和栈中<br>变量赋值，两个变量参加运算互不影响 变量赋值，对象引用，互相影响<br>JS的数据类型：基本类型+引用类型</p><p>事件捕获/冒泡/委托<br>垂直居中<br>数据劫持：ES5中的object.defineProperty()</p><h2 id="组件化开发-amp-模块化开发："><a href="#组件化开发-amp-模块化开发：" class="headerlink" title="组件化开发&amp;模块化开发："></a>组件化开发&amp;模块化开发：</h2><p>模块化中的模块一般指的是JavaScript中的模块，比如用来格式化时间的模块<br>一个模块就是实现特定功能的文件，有了模块我们就可以方便的使用别人的代码，想要什么功能就加载什么模块。<br>组件则包含了template、script和style，而它的script可以由不同功能的模板组成；比如一个显示时间的组件会调用上面那个格式化时间的模块。<br>模块化诉求的是解耦，组件化诉求的是好用</p><h2 id="高内聚，低耦合："><a href="#高内聚，低耦合：" class="headerlink" title="高内聚，低耦合："></a>高内聚，低耦合：</h2><p>含义：把内在关联密切的功能/实现放在一个模块中，最小化暴露給外部的细节和依赖<br>模块之间低耦合，模块内部高内聚<br>1.高内聚—-一个系统有多个模块组成，在划分模块时，要把功能关系紧密的放在一个模块中<br>2.低耦合—-功能关系远的放到其他模块中，模块之间的联系越少越好，接口越简单越好<br>如果划分的模块之间的接口很复杂，说明功能划分的不是很合理，模块之间的耦合度太高，也说明了模块内的内聚也不高<br>3.解耦：<br>解耦就是让各个模块尽可能独立，这样的好处是尽可能的让各个模块的维护人员更专注模块本身的功能和完善，至于模块怎么划分，可以根据功能也可以根据业务需求。<br>降低耦合度最基本的我们应该少用全局变量。</p><h2 id="为什么会有前端框架"><a href="#为什么会有前端框架" class="headerlink" title="为什么会有前端框架"></a>为什么会有前端框架</h2><p>在实际开发中，不是每个项目都需要用到框架的，如果项目较小，本身前端方面要求不是很高，那其实确实不是很需要框架，但是随着需求的变化，功能的增加，要满足越来越多的需求，<br>框架就有非常重要的作用了。<br>框架的使用可以节省开发时间，提高代码重用性，让开发变得更简单。<br>框架不同，适合场景也有所不同，得了解其适用场景才能充分发挥框架的作用，而不至于用了一个很复杂的框架，实际上只需要其中的很小一部分功能。<br>至于如何用，满足工作需要，那就好好了解官方文档，熟练使用其中的接口即可。如果想要学到更多，那就深入理解，看看你感兴趣的框架功能的实现，充分了解之后，可以根据实际项目，<br>定制自己的框架，或者修改已有的框架，让其更适合你的项目。</p><h2 id="框架和库："><a href="#框架和库：" class="headerlink" title="框架和库："></a>框架和库：</h2><ol><li>库：库是更多是一个封装好的特定的集合，提供给开发者使用，而且是特定于某一方面的集合（方法和函数），库没有控制权，控制权在使用者手中，在库中查询需要的功能在自己的应用<br>中使用，我们可以从封装的角度理解库；jQuery</li><li>框架：框架顾名思义就是一套架构，会基于自身的特点向用户提供一套相当于叫完整的解决方案，而且控制权的在框架本身，使用者要找框架<br>所规定的某种规范进行开发。Bootstrap、Vue、Angular</li></ol><p>##库、插件、组件、控件、扩展</p><ol><li>组件本质：封装。一定程度上可以约等于模块化，调用者只需关注输入和输出，总思想就是分而治之、重复利用。低耦合；<br>组件解决资源整合问题、增强功能促进开发效率。提高可维护性，便于协同开发，每个模块都可以分拆为一个组件，例如异步请求组件，路由组件，各个视图组件。</li><li>库：为解决某种特定需求的程序功能集合；即library，如jquery，常用于方便dom操作、解决浏览器兼容等问题。</li><li>插件：参与程序内部运行环节的一段或多段代码集合；即Plugin，遵循一定规范写出来方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件，</li><li>扩展：使用程序API扩展程序适用面的一段或多段代码集合；即Extension，</li><li>组件：可重复使用并且可以和其他对象进行交互的对象；即Component，能复用的js代码其实跟插件差不多，区别可能就是插件专注于特定功能而组件更专注于复用吧。</li><li>控件：提供或实现用户界面功能的组件，控件即组件，反之不一定。即Control，</li></ol><p>组件(Component)是是一个含义很大的概念，一般是指软件系统的一部分，承担了特定的职责，可以独立于整个系统进行开发和测试，一个良好设计的组件应该可以在不同的软件系统中被使用<br>(可复用)。例如V8引擎是Chrome浏览器的一部分，负责运行JavaScript代码，这里V8引擎就可以视为一个组件。V8引擎同时也是Node.js的javascript解释器，这体现了组件的可复用性。<br>库(Library)是一系列预先定义好的数据结构和函数(对于面向对象语言来说，是类)的集合，程序员通过使用这些数据结构和函数实现功能。例如Moment.js是一个javascript库，提供了处理时<br>间的一些函数。<br>框架(Framework)也是一系列预先定义好的数据结构和函数，一般用于作为一个软件的骨架，但程序真正的功能还需要由开发者实现。框架和库的最大区别在于“控制反转”，当你使用一个库，<br>你会调用库中的代码，而当你使用一个框架，框架会调用你的代码。框架和库是一个有交叉的概念，很多框架都是以库的形式发布的，例如Java的Spring MVC框架，其发布的jar包本身就是一<br>个库。而一个库如果也能通过依赖反转的方式进行扩展，那也可以视为一个框架，例如Python的markdonw解析库Python Markdown，可以添加自定义的解析扩展，那么可以被视为一个markdonw<br>解析框架。</p><h2 id="Angular-js的优缺点："><a href="#Angular-js的优缺点：" class="headerlink" title="Angular.js的优缺点："></a>Angular.js的优缺点：</h2><p>优点：</p><ol><li>模板功能强大丰富，并且是声明式的，自带了丰富的Angular指令；</li><li>是一个比较完善的前端MV*框架，包含模板，数据双向绑定，路由，模块化，服务，过滤器，依赖注入等所有功能；</li><li>自定义Directive，比jQuery插件还灵活，但是需要深入了解Directive的一些特性，简单的封装容易，复杂一点官方没有提供详细的介绍文档，我们可以通过阅读源代码来找到某些我们需要的东西，如：在directive使用 $parse；</li><li>ng模块化比较大胆的引入了Java的一些东西（依赖注入），能够很容易的写出可复用的代码，对于敏捷开发的团队来说非常有帮助，我们的项目从上线到目前，UI变化很大，在摸索中迭代产品，但是js的代码基本上很少改动。</li><li>补充：Angular支持单元测试和e2e-testing。</li></ol><p>缺点：</p><ol><li>验证功能错误信息显示比较薄弱，需要写很多模板标签，没有jQuery Validate方便，所以我们自己封装了验证的错误信息提示，详细参考 why520crazy/w5c-validator-angular · GitHub ；</li><li>ngView只能有一个，不能嵌套多个视图，虽然有 angular-ui/ui-router · GitHub 解决，但是貌似ui-router 对于URL的控制不是很灵活，必须是嵌套式的（也许我没有深入了解或者新版本有改进）；</li><li>对于特别复杂的应用场景，貌似性能有点问题，特别是在Windows下使用chrome浏览器，不知道是内存泄漏了还是什么其他问题，没有找到好的解决方案，奇怪的是在IE10下反而很快，对此还在观察中；</li><li>这次从1.0.X升级到1.2.X，貌似有比较大的调整，没有完美兼容低版本，升级之后可能会导致一个兼容性的BUG，具体详细信息参考官方文档 AngularJS ，对应的中文版本：Angular 1.0到1.2 迁移指南</li><li>ng提倡在控制器里面不要有操作DOM的代码，对于一些jQuery 插件的使用，如果想不破坏代码的整洁性，需要写一些directive去封装插件，但是现在有很多插件的版本已经支持Angular了，如：jQuery File Upload Demo</li><li>Angular 太笨重了，没有让用户选择一个轻量级的版本，当然1.2.X后，Angular也在做一些更改，比如把route，animate等模块独立出去，让用户自己去选择。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Angular、vue、react-数据双向绑定的原理&quot;&gt;&lt;a href=&quot;#Angular、vue、react-数据双向绑定的原理&quot; class=&quot;headerlink&quot; title=&quot;Angular、vue、react 数据双向绑定的原理&quot;&gt;&lt;/a&gt;Angul
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博文公园(Web随心记5)</title>
    <link href="http://yoursite.com/2017/09/10/Web%E9%9A%8F%E5%BF%83%E8%AE%B05/"/>
    <id>http://yoursite.com/2017/09/10/Web随心记5/</id>
    <published>2017-09-10T05:55:04.290Z</published>
    <updated>2017-09-10T06:39:34.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>ajax的兼容性写法</li></ol><p>性能优化<br>1.减少http请求<br>    (1)减少DNS请求所耗费的时间<br>    (2)减少服务器压力<br>    (3)减少http请求头<br>2.减少dom节点：加速页面渲染<br>3.用link标签加载css资源而不用@import方式导入样式<br>4.样式放在页头，js放在页尾<br>5.尽量少用全局变量</p><ol><li>Nodejs可以监听80端口吗？</li></ol><p>不可以，Window下Nodejs监听80端口提示端口会被占用报错，解决方案如下：<br>1、cmd—netstat -ano查看是什么程序占用了80端口；<br>2、控制面板–管理工具–服务–停止 SQL Server ReportingServices这个服务；<br>然后 nodejs就能直接通过域名绑定 80端口了。</p><ol><li>事件委托：</li></ol><p>利用事件冒泡的原理，让本来该自己触发的事件，让他的父元素代替执行；<br>利用时间委托技术能让我们避免对每个特定的节点添加事件，事件只需要添加到他们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 找到父元素，添加监听器</div><div class="line">document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;,function(e)&#123;</div><div class="line">  //e.target是被点击的元素！</div><div class="line">  //如果被点击的是li元素</div><div class="line">  if(e.target &amp;&amp; e.target.nodeName == &quot;LI&quot;)&#123;</div><div class="line">    // 找到目标，输出ID</div><div class="line">    console.log(&quot;List item&quot;, e.target.id.replace(&quot;post-&quot;),&quot;was clicked!&quot;)</div><div class="line">  &#125;</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><ol><li>Javascript的事件流模型都有什么？</li></ol><p>‘DOM事件流’三个阶段：事件捕获、目标阶段、事件冒泡<br>‘事件冒泡’：事件开始由最具体的元素接收，然后逐级向上传播<br>‘事件捕获’：事件由最不具体的节点先接收，然后逐级向下传播，直达最具体的</p><h3 id="5-JS的IE和Firefox（MF）兼容性汇总？http-blog-sina-com-cn-s-blog-5656b0020100dbu2-html"><a href="#5-JS的IE和Firefox（MF）兼容性汇总？http-blog-sina-com-cn-s-blog-5656b0020100dbu2-html" class="headerlink" title="5.JS的IE和Firefox（MF）兼容性汇总？http://blog.sina.com.cn/s/blog_5656b0020100dbu2.html"></a>5.JS的IE和Firefox（MF）兼容性汇总？<a href="http://blog.sina.com.cn/s/blog_5656b0020100dbu2.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_5656b0020100dbu2.html</a></h3><ol><li>document.form.item 问题</li></ol><p>(1)现有问题：<br>        现有代码中存在许多 document.formName.item(“itemName”) 这样的语句，不能在 MF 下运行<br>(2)解决方法：<br>        改用 document.formName.elements[“elementName”]</p><ol><li>集合类对象问题</li></ol><p>(1)现有问题：<br>        现有代码中许多集合类对象取用时使用 ()，IE 能接受，MF 不能。<br>(2)解决方法：<br>        改用 [] 作为下标运算。如：document.forms(“formName”) 改为 document.forms[“formName”]。<br>        又如：document.getElementsByName(“inputName”)(1) 改为 document.getElementsByName(“inputName”)[1]</p><ol><li>HTML 对象的 id 作为对象名的问题</li></ol><p>(1)现有问题<br>        在 IE 中，HTML 对象的 ID 可以作为 document 的下属对象变量名直接使用。在 MF 中不能。<br>(2)解决方法<br>        用 getElementById(“idName”) 代替 idName 作为对象变量使用。</p><ol><li>用idName字符串取得对象的问题</li></ol><p>(1)现有问题<br>        在IE中，利用 (idName) 可以取得 id 为 idName 的 HTML 对象，在MF 中不能。<br>(2)解决方法<br>        用 getElementById(idName) 代替 (idName)。</p><ol><li>event.x 与 event.y 问题</li></ol><p>(1)现有问题<br>        在IE 中，event 对象有 x, y 属性，MF中没有。<br>(2)解决方法<br>        在MF中，与event.x 等效的是 event.pageX。但event.pageX IE中没有。<br>        故采用 event.clientX 代替 event.x。在IE 中也有这个变量。<br>        event.clientX 与 event.pageX 有微妙的差别（当整个页面有滚动条的时候），不过大多数时候是等效的。<br>如果要完全一样，可以稍麻烦些：<br>        mX = event.x ? event.x : event.pageX;<br>        然后用 mX 代替 event.x</p><ol><li>const 问题  </li></ol><p>(1)现有问题:<br>     在 IE 中不能使用 const 关键字。如 const constVar = 32; 在IE中这是语法错误。<br>(2)解决方法:<br>     不使用 const ，以 var 代替。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;ajax的兼容性写法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;性能优化&lt;br&gt;1.减少http请求&lt;br&gt;    (1)减少DNS请求所耗费
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博文公园(Web随心记4)</title>
    <link href="http://yoursite.com/2017/09/10/Web%E9%9A%8F%E5%BF%83%E8%AE%B04/"/>
    <id>http://yoursite.com/2017/09/10/Web随心记4/</id>
    <published>2017-09-10T05:53:28.899Z</published>
    <updated>2017-09-10T06:38:39.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="8-Angular项目开发，MVC、MVVM开发模式，spa程序开发"><a href="#8-Angular项目开发，MVC、MVVM开发模式，spa程序开发" class="headerlink" title="8. Angular项目开发，MVC、MVVM开发模式，spa程序开发"></a>8. Angular项目开发，MVC、MVVM开发模式，spa程序开发</h3><ol><li>angular是什么</li></ol><p>前端JS框架，最为核心的是：MVC、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。<br>AngularJS是一款由Google公司开发维护的前端MVC框架，其克服了HTML在构建应用上的诸多不足，从而降低了开发成本提升了开发效率。<br>AngularJS 是一个 JavaScript 框架。它是一个以 JavaScript 编写的库。<br>AngularJS 是以一个 JavaScript 文件形式发布的，可通过 script 标签添加到网页中：</p><p>Angular :<br>Angualr是一个JavaScript框架，以JavaScript文件发布的，可以通过script标签添加到网页中<br>Angular是一款由Google公司开发维护的的前端MVC框架<br>Angular和jQuery是有一定区别的：jQuery更准确的说是一个类库（类库是指一系列函数的聚合），以DOM作为驱动<br>而angular则是一个框架（诸多类库的集合），以数据和逻辑为驱动<br>Angular有诸多的特性，最为核心的有：模块化、数据双向绑定，语义化标签，依赖注入等</p><ol><li>MVC :</li></ol><p>是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计规范，用一种业务逻辑、数据、界面显示分离的方法组织代码<br>MVC模式的意思是，软件可以分成三个部分。<br>视图（View）：用户界面。<br>控制器（Controller）：业务逻辑<br>模型（Model）：数据保存</p><p>1.View 传送指令到 Controller<br>2.Controller 完成业务逻辑后，要求 Model 改变状态<br>3.Model 将新的数据发送到 View，用户得到反馈<br>所有通信都是单向的。<br>所谓的MVC就是 我们把网页代码按照视图 ，数据模型 和 控制器的方式进行分离；视图控制网页格式，数据模型控制数据，控制器就是联系数据和模板之间如何工作的逻辑代码。</p><p>MVC是一种开发模式 module view controller<br>模型（module）用来读取/设置/处理数据，一般指操作数据库<br>视图（view）一般用来展示数据，通过HTML标签展示数据<br>控制器（controller）一般用来连接模型和视图的桥梁</p><ol><li>MVVM :</li></ol><p>它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel<br>MVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。</p><p>MVVM是MVC的变种和进阶，<br>M—-&gt; model 模型层（一般用于数据存储，存储一些业务逻辑），也就是我们说的数据模型。<br>V—–&gt; view 视图层（界面），用来展示数据。<br>VM–&gt; ViewModel（视图模型） 也就是$scope。</p><p>在实际应用中，更多的是进行页面交互，而最后一次性向服务器提交处理（弱化了MVC中控制器的功能），增强了视图与模型的使用，因此将此称之为MVVM.</p><ol><li>模块化：</li></ol><p>使用angular构建应用APP时是以模块（module）的方式组织的，将整个应用划分成若干个模块，每个模块各司其职，最终组成一个整体</p><ol><li>指令（属性）：</li></ol><p>所谓指令就是angular自定义属性或标签<br>内置指令：<br>ng-app=“APP”—指定应用根元素<br>Ng-controller—指定控制器<br>Ng-show，ng-hide，ng-if，ng-href， ng-class， ng-src</p><ol><li>自定义指令（directive）：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Angular允许根据实际业务需要自定义指令，通过angular全局对象下的directive方法</div><div class="line">指令系统一共可以定义4种类型的指令</div><div class="line">Restrict： “E”----元素element</div><div class="line">Restrict： “A”----属性attribute</div><div class="line">Restrict： “C”----类名class</div><div class="line">Restrict： “M”----注释comment</div><div class="line"></div><div class="line">Var APP = angular.module(‘app’, []);</div><div class="line">App.directive(‘Directives’,function()&#123;</div><div class="line">Return &#123;</div><div class="line">   Restrict: “E”,</div><div class="line">   Tempalte: ‘&lt;button class=”btn, btn-lg”&gt;&lt;/button&gt;’,</div><div class="line">   Replace: true</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><ol><li>数据绑定：</li></ol><p>Angular是以数据为驱动的MVC框架，所有模型（module）里的数据都是经过控制器（controller）展示到视图（view）上的<br>所谓的数据绑定就是将模型（module）中的数据与相应的视图（view）进行关联<br>分为单向数据绑定和双向数据绑定：<br>单向数据绑定：将模型（module）中的数据通过模板引擎渲染到页面视图（view）上<br>或将视图（view）中绑定ng-model的数据传递给模型（module）中<br>双向数据绑定：将视图（view）中绑定ng-model的数据传递给模型（module），然后再把模型（module）中的数据渲染到页面视图（view）上</p><ol><li>路由：</li></ol><p>一个应用由多个视图组成，根据不同的业务逻辑展示给用户不同的视图，路由就是实现这个功能的关键<br>SPA（single page application）指的是通过单一页面展示所有的功能，通过http请求动态获取数据进行实时渲染；<br>SPA原理：在开发单页面应用时，所有的功能都在同一个页面完成，所以无需切换URL地址（不允许发生跳转），但web应用中又经常通过a标签来更新页面（视图），<br>当点击链接时要阻止其向服务器发起请求，通过锚点（锚链接）可以实现这一点<br>通过hashchange事件可以实时监测到地址的变化（location.hash）<br>Angular对这一现实原理进行了封装，将锚点的变化封装成路由（route）<br>Angular-route</p><p>Ng-repeat 迭代数组的时候，如果数组中有相同的值，会报错，说值重复了。<br>解决方法：ng-repeat=”item in items track by $index”</p><p>Ng-click中写的表达式，不能使用JS原生对象上的方法，因为这些不是存在于与页面对用的Controller的$scope中。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;&#123;&#123;parseInt(10.01)&#125;&#125;&lt;/p&gt;这样写是不可以的</div><div class="line">应该写成：</div><div class="line">$scope.parseInt = function(x)&#123;rentrun parseInt(x)&#125;;</div><div class="line">或定义一个过滤器：</div><div class="line">App.filter(“parseIntFilter”, function() &#123;return function(x)&#123;reurn parseInt(x)&#125;&#125;);</div><div class="line">&lt;p&gt;&#123;10.01 | parseIntFilter&#125;&#125;&lt;/p&gt;</div></pre></td></tr></table></figure><ol><li>依赖注入：</li></ol><p>所谓依赖注册是指运行时自动查找依赖关系，然后将查找到的依赖传递给使用者的一种机制。<br>通俗的讲就是通过注入的方式解决依赖；<br>（1）行内注入：用数组的方式明确声明依赖，数组的最后一个元素是依赖注入的目标函数<br>（2）推断式注入：没有明确声明依赖，angular会将函数参数名当成依赖依赖的名称。这种方式会出现一个问题，当代码被压缩后函数的参数也会被压缩，会造成依赖无法找到。</p><h3 id="7-使用-SVN-Git-代码版本管理器"><a href="#7-使用-SVN-Git-代码版本管理器" class="headerlink" title="7. 使用 SVN/Git 代码版本管理器"></a>7. 使用 SVN/Git 代码版本管理器</h3><p>最核心的区别Git是分布式的，而Svn不是分布的。</p><p>git init 初始化一个仓库<br>git commit -m ‘注释’  提交<br>git push   推送到远程<br>git pull<br>git checkout -b 分支名   创建并进入分支<br>git checkout 分支名  切换分支</p><h3 id="8-项目构建工具Webpack、Gulp"><a href="#8-项目构建工具Webpack、Gulp" class="headerlink" title="8. 项目构建工具Webpack、Gulp"></a>8. 项目构建工具Webpack、Gulp</h3><p>多个开发者共同开发一个项目，每位开发者负责不同的模块，这就会造成一个完整的项目实际上是由许多的“代码版段”组成的；<br>使用less、sass等一些预处理程序，降低CSS的维护成本，最终需要将这些预处理程序进行解析；<br>合并css、javascript，压缩html、css、javascript、images可以加速网页打开速度，提升性能；<br>这一系列的任务完全靠手动完成几乎是不可能的，借助构建工具可以轻松实现。<br>所谓构建工具是指通过简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。<br>常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack</p><p>Gulp是基于Nodejs开发的一个构建工具，借助gulp可以实现不同的构建任务，以其简洁的配置和卓越的性能称为目前最主流的构建工具（npm install -g gulp）</p><p>gulp是什么<br>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器<br>gulp可以通过各种插件完成代码构建任务，如：文件合并，文本替换，图片-css-js压缩等<br>gulp.task() 定义一个任务<br>gulp.pipe() 将需要构建的资源输送给插件，类比于管道<br>gulp。dest() 将构建完成之后的资源存放到指定路径<br>gulp.watch() 监听</p><p>常用插件<br>gulp-less 编译LESS文件<br>gulp-autoprefixer 添加CSS私有前缀<br>gulp-cssmin 压缩CSS<br>gulp-rename重命名<br>gulp-imagemin 图片压缩<br>gulp-uglify 压缩Javascript（会自动删除没有用的变量）<br>gulp-concat 合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//less任务名称 回调方法里定义任务</div><div class="line">gulp.task(&apos;less&apos;,function()&#123;</div><div class="line">  // 需要编译的less</div><div class="line">  gulp.src(&apos;./piblic/less/**/.js&apos;)</div><div class="line">  // 将src获取的资源传递给less插件</div><div class="line">  .pipe(less())</div><div class="line">  // 将 less插件编译好的文件存储</div><div class="line">  .pipe(gulp.dest(&apos;./public/css&apos;));</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;8-Angular项目开发，MVC、MVVM开发模式，spa程序开发&quot;&gt;&lt;a href=&quot;#8-Angular项目开发，MVC、MVVM开发模式，spa程序开发&quot; class=&quot;headerlink&quot; title=&quot;8. Angular项目开发，MVC、MVVM开
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博文公园(Web随心记3)</title>
    <link href="http://yoursite.com/2017/09/10/Web%E9%9A%8F%E5%BF%83%E8%AE%B03/"/>
    <id>http://yoursite.com/2017/09/10/Web随心记3/</id>
    <published>2017-09-10T05:52:15.927Z</published>
    <updated>2017-09-10T06:36:05.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Nodejs环境-Node-Package-Manager-验证-node-v-npm-v"><a href="#安装Nodejs环境-Node-Package-Manager-验证-node-v-npm-v" class="headerlink" title="安装Nodejs环境 Node Package Manager (验证 node -v  npm -v)"></a>安装Nodejs环境 Node Package Manager (验证 node -v  npm -v)</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">  编译方法有两种：</div><div class="line">    1. 用node.js</div><div class="line">    2. 引入less.js      type=stylesheet/less  </div><div class="line">  定义变量：</div><div class="line">    @base: #f938ab;</div><div class="line">  函数：</div><div class="line">  //定义函数</div><div class="line">//  .border-radius( @style )&#123;</div><div class="line">//    -moz-border-radius: @style;</div><div class="line">//    -webkit-border-radius: @style; </div><div class="line">//    border-radius: @style; </div><div class="line">//  &#125;</div><div class="line"></div><div class="line">//  .box &#123;</div><div class="line">    //使用函数</div><div class="line">//    .border-radius(5px solid blue)</div><div class="line">//  &#125;</div><div class="line"></div><div class="line">  //编译之后</div><div class="line">//  .box &#123;</div><div class="line">//    -moz-border-radius: 5px solid blue;</div><div class="line">//    -webkit-border-radius: 5px solid blue;</div><div class="line">//    border-radius: 5px solid blue;</div><div class="line">//  &#125;</div><div class="line"></div><div class="line">  字符串和数学方法</div><div class="line"></div><div class="line">  //将字符串Mars? 替换成Earth!</div><div class="line">  @str : replace(&quot;Hello, Mars e Mars?&quot;, &quot;Mars\?&quot;, &quot;Earth!&quot;);</div><div class="line"></div><div class="line">//  .box &#123;</div><div class="line">//    font-family: @str ;</div><div class="line">//    font-size: ceil(2.0) ;  //向上取整</div><div class="line">//    width: floor(26.9) ;    //向下取整</div><div class="line">//  &#125;</div><div class="line"></div><div class="line">  编译结果</div><div class="line">//  .box &#123;</div><div class="line">//    font-family: &quot;Hello, Mars e Earth!&quot;;</div><div class="line">//    font-size: 2;</div><div class="line">//    width: 26;</div><div class="line">//  &#125;</div><div class="line">  判断方法 --&gt;</div></pre></td></tr></table></figure><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><ol><li>jquery :jquerys是一个快速、简洁的JavaScript框架，主要用于dom操作</li></ol><p>选择器啊，复选框啊，表单啊，ajax啊，事件等<br>基本选择器，层次选择器，过滤选择器，表单选择器</p><p>window.onload 事件和 jQuery ready 函数之间的主要区别是，前者除了要等待 DOM 被创建还要等到包括大型图片、音频、视频在内的所有外部资源都完全加载。如果加载图片和<br>媒体内容花费了大量时间，用户就会感受到定义在 window.onload 事件上的代码在执行时有明显的延迟。<br>另一方面，jQuery ready() 函数只需对 DOM 树的等待，而无需对图像或外部资源加载的等待，从而执行起来更快。使用 jQuery $(document).ready() 的另一个优势是你可以在网<br>页里多次使用它，浏览器会按它们在 HTML 页面里出现的顺序执行它们，相反对于 onload 技术而言，只能在单一函数里使用。鉴于这个好处，用 jQuery ready() 函数比用 JavaScript<br> window.onload 事件要更好些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[jQuery  1.4 &amp; 1.7最稳定1.8.3 最好用1.9 有bug是JavaScript的一个框架库，封装了很多代码（包括函数，兼容的代码，对象）</div><div class="line">的一个文件；一个JS文件中封装了很多兼容和比较方便的代码，就可以把这个js文件看成一个库。JS是一个框架库，函数库；JS解</div><div class="line">决了很多兼容问题，但会出现很多css兼容问题，因为jQuery是以JS为基础，只封装了js代码。You call Library.Framework calls you.</div><div class="line">（你调用库，框架调用你）</div><div class="line"></div><div class="line">jQuery的特点：write less, do more.</div><div class="line">体积小，兼容兼容问题，链式编程，隐式迭代，开源，插件丰富，最主要的是免费，哈哈]</div></pre></td></tr></table></figure><h3 id="jQuery中事件绑定和解绑"><a href="#jQuery中事件绑定和解绑" class="headerlink" title="jQuery中事件绑定和解绑"></a>jQuery中事件绑定和解绑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">绑定事件                                      解绑</div><div class="line">$(“#btn”).click(function()&#123;&#125;);                $(“#btn”).</div><div class="line">$(“#btn”).bind(function()&#123;&#125;);                 $(“#btn”).unbind();</div><div class="line">$(“div”).delegate(“p”, “click”,function()&#123;&#125;); $(“div”).undelegate(“p”, “click”);</div><div class="line">$(“#dv”).on(“click”, “p”, function()&#123;&#125;);      $(“#dv”).off(“click”, “p”);</div></pre></td></tr></table></figure><h3 id="jQuery的优化方法有哪些："><a href="#jQuery的优化方法有哪些：" class="headerlink" title="jQuery的优化方法有哪些："></a>jQuery的优化方法有哪些：</h3><p><a href="http://www.jb51.net/article/87002.htm" target="_blank" rel="external">http://www.jb51.net/article/87002.htm</a></p><ol><li>使用#id寻找element</li></ol><p>jQuery中最快的选择器是ID选择器（getelementById（））</p><ol><li>在jQuery中第二快的是标签选择器（getelementByTegName()）</li></ol><p>注意：在jQuery里Class选择器是最慢的一个选择器;在IE中它循环整个DOM。可能的话尽量避免使用它。不要在ID前面 加Tags。例如，它会因为去循环所有的<div>元素去寻找ID为content的</div></p><p><div>，而导致很慢。</div></p><ol><li>缓存jQuery对象</li></ol><p>养成保存jQuery对象到一个变量上（就像上面的例子）的习惯。<br>提示：使用$前辍表示我们的本地变量是一个jQuery包集。记住，不要在你的应该程序里出现一次以上的jQuery重复的选择操作。 额外提示：延迟存储jQuery对象结果。<br>如果你想在你的程序的其它地方使用jQuery结果对象（result object(s)），或者你的函数要执行多次，要把它缓存在一个全局范围的对象里。通过定义一个全局容器保存jQuery结果对象，<br>就可以在其它的函数里引用它。</p><ol><li>使用链式编程：</li></ol><p>var $active_light = $(‘#traffic_light input.on’);<br>$active_light.bind(‘click’, function(){…}).css(‘border’, ‘3px dashed yellow’).css(‘background-color’, ‘orange’).fadeIn(‘slow’);</p><ol><li>使用子查询</li></ol><p>jQuery允许我们在一个包集上附加其它的选择器。因为我们已经在本地变量里保存了父对象这样会减少以后在选择器上的性能开销。</p><ol><li>限制对DOM元素的直接操作</li><li>事件委托（又名：冒泡事件）</li></ol><p>利用事件冒泡的原理，让本来该自己触发的事件，让他的父元素代替执行；<br>利用时间委托技术能让我们避免对每个特定的节点添加事件，事件只需要添加到他们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。</p><ol><li>消除查询浪费</li><li>遵循$(window).load</li><li>压缩js</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Nodejs环境-Node-Package-Manager-验证-node-v-npm-v&quot;&gt;&lt;a href=&quot;#安装Nodejs环境-Node-Package-Manager-验证-node-v-npm-v&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博文公园(Web随心记2)</title>
    <link href="http://yoursite.com/2017/09/10/Web%E9%9A%8F%E5%BF%83%E8%AE%B02/"/>
    <id>http://yoursite.com/2017/09/10/Web随心记2/</id>
    <published>2017-09-10T05:44:37.095Z</published>
    <updated>2017-09-10T06:06:18.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="技术掌握"><a href="#技术掌握" class="headerlink" title="技术掌握"></a>技术掌握</h1><h3 id="1-HTML-和-CSS，书写语义合理、结构清晰、易于维护的页面结构，还原设计图，并处流浏览器的兼容性问题；"><a href="#1-HTML-和-CSS，书写语义合理、结构清晰、易于维护的页面结构，还原设计图，并处流浏览器的兼容性问题；" class="headerlink" title="1. HTML 和 CSS，书写语义合理、结构清晰、易于维护的页面结构，还原设计图，并处流浏览器的兼容性问题；"></a>1. HTML 和 CSS，书写语义合理、结构清晰、易于维护的页面结构，还原设计图，并处流浏览器的兼容性问题；</h3><ol><li>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</li><li>在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构;</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li><li>HTML是结构  css是样式  js是行为</li></ol><ul><li>浏览器兼容性：</li></ul><ol><li>透明度filter: alpha(opacity=60); /<em> for IE5-7 </em>/</li><li>双边距BUG float引起的  使用_display:inline;</li><li>IE6不支持PNG透明背景，解决办法: IE6下使用gif图片</li><li>IE下可以box[‘data-title’]  也可以box.getAttribute(‘’data-title’)获取自定义，但是谷歌和火狐不可以</li><li>IE8的window.event没有pagex pagey</li></ol><h3 id="2-理解JavaScript高级特性（如OP、继承、原型链、闭包等），ES6新特性；"><a href="#2-理解JavaScript高级特性（如OP、继承、原型链、闭包等），ES6新特性；" class="headerlink" title="2. 理解JavaScript高级特性（如OP、继承、原型链、闭包等），ES6新特性；"></a>2. 理解JavaScript高级特性（如OP、继承、原型链、闭包等），ES6新特性；</h3><p>JS是一门弱类（变量都用var）动态类型解释性脚本（不需要编译）语言</p><ol><li><p>OOP:面向对象，面向对象是一种编程思想，用一句话说就是封装，继承，多态。在JavaScript是弱类型语言天然具备多态的特性。使用函数进行封装，通过原型实现继承；</p></li><li><p>原型是一个对象，其他对象可以通过它实现属性继承。继承有原型继承，构造函数继承，混合继承，JavaScript通过混合继承实现面向对象思想。原型继承缺点是属性和方法都共享了，<br>构造函数继承缺点是浪费内存，所以结合构造函数继承和原型继承实现面向对象。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">原型是一个对象，其他对象可以通过它实现属性的继承</div><div class="line">原型prototype是构造函数的属性，本质是对象（可理解成object的实例对象）</div><div class="line">原型继承  修改子集构造函数的prototype指向父级构造函数的实例对象</div><div class="line">  缺点：不能给父级构造函数传递参数</div><div class="line">父级构造函数中的引用类型的数据会被子集构造函数实例共享</div><div class="line">构造函数继承  目的：把父级所有的属性继承过来 </div><div class="line">  缺点：无法继承父级构造函数原型中的成员</div><div class="line">混合继承  组合原型继承和构造函数继承</div><div class="line">  代码有冗余，浪费内容，但其带来的好处远大于这点内存</div></pre></td></tr></table></figure><ol><li><p>闭包用一句话说拿到你不该拿的东西，代码实现是函数里面return 一个函数，自执行函数也是闭包也叫作沙箱就是让内部变量不会污染全局；闭包的特点是闭包可以读取函数内部变量，<br>将函数内部变量的值始终保存在内存中，保护函数内的变量不被更改；闭包的用途：缓存数据提高计算性能，</p></li><li><p>ES6 let 其声明的变量只在当前代码块中有效</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">       ES6中定义了块级作用域（&#123; &#125;）</div><div class="line">       let（声明变量）  const（声明常量）</div><div class="line">面试       变量的解构赋值：按照某种模式，从数组和对象中提取值并对对象进行赋值称为解构</div><div class="line">       箭头函数 () =&gt; &#123;&#125;</div><div class="line">       数组扩展，字符串扩展，函数扩展</div><div class="line">相当于是创建了块级作用域, const定义常量不能更改但是可以更改对象里属性；变量的解构赋值[a,b,c] = [1,2,3] ; 箭头函数 ；数组扩展Array.from()  Array.of()</div></pre></td></tr></table></figure><h3 id="3-使用-Ajax-进行前后台数据交互-使用-JSONP-解决浏览器常见的跨域请求问题"><a href="#3-使用-Ajax-进行前后台数据交互-使用-JSONP-解决浏览器常见的跨域请求问题" class="headerlink" title="3. 使用 Ajax 进行前后台数据交互,使用 JSONP 解决浏览器常见的跨域请求问题;"></a>3. 使用 Ajax 进行前后台数据交互,使用 JSONP 解决浏览器常见的跨域请求问题;</h3><h5 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax:"></a>Ajax:</h5><ol><li>为什么要进行异步加载：</li></ol><p>静态网站和动态网站都是同步的，同步开发的缺点：页面请求响应式阻塞，影响用户体验，为了解决这个问题，可以通过变通的手段实现页面的局部更新（隐藏帧），<br>由于隐藏帧不方面，就有了ajax</p><ol><li>哪些方法可以实现异步加载：</li></ol><p>（1）动态插入script标签<br>（2）通过ajax获取JS代码，然后通过eval执行<br>（3）Script标签添加defer或async属性<br>（4）创建并插入iframe,让它异步加载JS<br>（5）ajax</p><ol><li>简述ajax的过程：</li></ol><p>（1）创建xhr对象—-xhr = new XMLHttpRequest();<br>（2）配置发送参数—-xhr.open(type,url,async);<br>（3）发送—-xhr.send(params);<br>（4）处理响应—-xhr.onreadystatechange = function(){};<br>或：<br>（1）创建XMLHttpRequest对象，也就是创建一个一度调用对象<br>（2）创阿一个新的http请求，并制定http请求的方式、地址、和验证信息<br>（3）设置响应http请求状态发生变化的函数<br>（4）发送http请求<br>（5）获取异步调用返回的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//1.创建xhr对象</div><div class="line">var xhr = new XMLHttpRequest( ) ;</div><div class="line">//2.配置发送参数</div><div class="line">xhr.open( ‘get/post’ , url );</div><div class="line">//3.发送</div><div class="line">xhr.send();</div><div class="line">//4.1处理响应（指定回调函数）是由浏览器自己调用</div><div class="line">xhr.onreadystatechange = function()&#123;&#125;</div></pre></td></tr></table></figure></p><ol><li>post请求要设置请求头</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</div><div class="line">readyState--XMLHttpRequest对象的处理状态</div><div class="line">responseText--用于获取服务器的响应文本</div><div class="line">responseXML--用于获取服务器端响应的XML文档对象</div><div class="line">status--该属性是服务器返回的状态文本信息（http协议的状态码）</div><div class="line">readyState:--请求响应过程中的五种状态</div><div class="line">0 --XMLHttpRequest对象还没有完成初始化</div><div class="line">1 --XMLHttpRequest对象开始发送请求</div><div class="line">2 --XMLHttpRequest对象的请求发送完成</div><div class="line">3 --XMLHttpRequest对象开始读取服务器的响应</div><div class="line">4 --XMLHttpRequest对象读取服务器响应结束</div></pre></td></tr></table></figure><ol><li>status:–http协议的状态码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">400--无法找到请求的资源</div><div class="line">401--访问资源的权限不足</div><div class="line">403--没有权限访问资源</div><div class="line">404--需要访问的资源不存在</div><div class="line">405--需要访问的资源被禁止</div><div class="line">407--访问的资源需要代理身份验证</div><div class="line">414--请求的url太长</div><div class="line">500--服务器内部错误</div><div class="line">304-- 重定向</div></pre></td></tr></table></figure><ol><li>Get 和 post 的区别：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">（1）内存不同：get提交数据最多是4KB。Post一般是80-100KB</div><div class="line">（2）请求参数放置位置：get提交的数据参数放在URL地址后面；</div><div class="line">              Post请求提交的数据放在请求体中</div><div class="line">（3）安全性：post请求比get请求方式安全</div><div class="line">（4）Get是向服务器索取数据的一种请求，post是向服务器提交数据的一种方式</div><div class="line">（5）Post提交需要设置请求头，get发送请求不用设置请求头</div><div class="line">（6）一般推荐用get方式发送请求</div></pre></td></tr></table></figure><ol><li>jsonp：跨域解决方案</li></ol><p>原理：动态创建script标签，利用script标签向外部网站请求数据不会被拒绝的特性，<br>实现<script src="www.xxx.com/public/libs/data.php?callback=fn"></script><br>Jsonp的本质是浏览器发送一个事先定义好的函数的名字给服务器，服务端获取这个函数的名字，然后拼接（）后，将其返回；<br>Jsonp是一种良好的跨域解决方案，原理时：src属性具有天然跨域的能力<br>跨域还可以用“反向代理”</p><ol><li>回调地狱</li></ol><p>相信经常使用ajax的前端小伙伴，都会遇到这样的困境：一个接口的参数会需要使用另一个接口获取。<br>年轻的前端可能会用同步去解决（笑~），因为我也这么干过，但是极度影响性能和用户体验。<br>正常的前端会把接口写在另一个接口的回调里。是这样不错，但是它增加了函数的嵌套深度也会造成一定的逻辑混乱。<br>也许有朋友会说，哪那么多毛病，解决问题不就好了吗？<br>但是，如果需要的是另外好几个接口的返回数据呢？这时候就会比较蛋疼了。这就是回调地狱！<br>当时依稀记得是使用了jQuery的 when .then方法去解决的。<br>直到遇见了Promise,它完美优雅的解决了回调地狱难题！<br>//创建一个Promise实例，获取数据。并把数据传递给处理函数resolve和reject。需要注意的是Promise在声明的时候就执行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">var getUserInfo=new Promise(function(resolve,reject)&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">        type:&quot;get&quot;,</div><div class="line">        url:&quot;index.aspx&quot;,</div><div class="line">        success:function(data)&#123;</div><div class="line">            if(data.Status==&quot;1&quot;)&#123;</div><div class="line">                resolve(data.ResultJson)//在异步操作成功时调用</div><div class="line">            &#125;else&#123;</div><div class="line">                reject(data.ErrMsg);//在异步操作失败时调用</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;)</div><div class="line">//另一个ajax Promise对象，</div><div class="line">var getDataList=new Promise(function(resolve,reject)&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">        type:&quot;get&quot;,</div><div class="line">        url:&quot;index.aspx&quot;,</div><div class="line">        success:function(data)&#123;</div><div class="line">            if(data.Status==&quot;1&quot;)&#123;</div><div class="line">                resolve(data.ResultJson)//在异步操作成功时调用</div><div class="line">            &#125;else&#123;</div><div class="line">                reject(data.ErrMsg);//在异步操作失败时调用</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;)</div><div class="line">//Promise的方法then,catch方法</div><div class="line">getUserInfo.then(function(ResultJson)&#123;</div><div class="line">    //通过拿到的数据渲染页面</div><div class="line">&#125;).catch(function(ErrMsg)&#123;</div><div class="line">    //获取数据失败时的处理逻辑</div><div class="line">&#125;)</div><div class="line">//Promise的all方法，等数组中的所有promise对象都完成执行</div><div class="line">Promise.all([getUserInfo,getDataList]).then(function([ResultJson1,ResultJson2])&#123;</div><div class="line">    //这里写等这两个ajax都成功返回数据才执行的业务逻辑</div><div class="line">&#125;)</div><div class="line"></div><div class="line">这样的代码分工非常明确，ajax就是拿数据的，.then .catch方法就是处理业务逻辑，代码异常清晰。</div><div class="line"></div><div class="line">Promise：</div><div class="line">Promise是ES6中解决一步嵌套的一种方案，promise是一个构造函数</div><div class="line">Const promise = new Promise(function(resolve,rejected)&#123;</div><div class="line">If(成功了)&#123;</div><div class="line">Resolve();</div><div class="line">&#125;else&#123;</div><div class="line">//失败了，调用rejected</div><div class="line">Rejected();</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line">Promise.then(function()&#123;&#125;);</div><div class="line">Promise.catch(function()&#123;&#125;);</div></pre></td></tr></table></figure><p>slice &amp; splice $ split<br>slice<br>（数组）  array.slice(start,end);<br>对数组进行部分截取，返回值是一个数组副本slice(startindex,endinedx);</p><p>slice<br>（字符串） string.slice(start, end);<br>splice （数组） Array.splice(start,deleteCount, item…..);<br>splice方法从array中移除一个或多个数组，并用新的item替换它们。</p><p>Split<br>（字符串） String.split(separator, limit);<br>：split方法把这个string分割成片段来创建一个字符串数组。<br>split方法（函数）：第一个参数：要干掉的字符串，第二个参数：想要几个元素</p><h3 id="4-流式布局和响应式原理-Bootstrap-前端框架，开发响应式页面；"><a href="#4-流式布局和响应式原理-Bootstrap-前端框架，开发响应式页面；" class="headerlink" title="4. 流式布局和响应式原理,Bootstrap 前端框架，开发响应式页面；"></a>4. 流式布局和响应式原理,Bootstrap 前端框架，开发响应式页面；</h3><p>流式布局也叫百分比布局，缺点是宽度使用百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，<br>但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。<br>rem: 通过媒体查询检查屏幕宽度设定html元素的font-size，然后各处（元素尺寸、文字大小）使用rem作为单位，随后搭配媒体查询或JS，根据屏幕的大小来动态控制html<br>元素的font-size,即可自动改变所有用rem定义尺寸的元素的大小.</p><ol><li>bootstrap: —–前端框架</li></ol><p>原理：媒体查询，在不同的屏幕宽度范围下使用不同的容器宽度。<br>随着Web应用变的越来越复杂，在大量的开发过程中我们发现有许多功能模块非常相似，比如轮播图、分页、选项卡、导航栏等，开发中往往会把这些具有通用性的功能模块进行<br>一系列封装，使之成为一个个组件应用到项目中，可以极大的节约开发成本，将这些通用的组件缩合到一起就形成了前端框架。<br>Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目。</p><ol><li>栅格布局：移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">“行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。</div><div class="line">通过“行（row）”在水平方向创建一组“列（column）”。</div><div class="line">你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。</div><div class="line">响应式工具：</div><div class="line">.visible-xs-*   超小屏幕手机 (&lt;768px)可见</div><div class="line">.visible-sm-*   小屏幕平板 (≥768px)可见</div></pre></td></tr></table></figure><h3 id="5-前端模块化开发，less-sass-等预处理；"><a href="#5-前端模块化开发，less-sass-等预处理；" class="headerlink" title="5. 前端模块化开发，less/sass 等预处理；"></a>5. 前端模块化开发，less/sass 等预处理；</h3><ol><li>requireJS</li></ol><p>业务多了，前端代码量也逐渐增大，我们渐渐的依赖js实现的交互越来越多，长期以来会导致我们的代码维护越来越困难；<br>RequireJS（模块加载器）是一个非常小巧的JavaScript模块载入框架，是AMD规范最好的实现者, 实现js文件的异步加载，避免网页失去响应；管理模块之间的依赖性，便于代码的编写和维护。</p><p>Asynchronous Module Definition，用白话文讲就是 异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。</p><ul><li>作用是：<ol><li>将公共功能进行封装实现复用；</li><li>灵活解决依赖；</li><li>解决全局变量污染；</li></ol></li></ul><ol><li>定义一个独立模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//独立模块，不依赖其他模块，可以直接定义</div><div class="line">define(&#123;</div><div class="line">  method1: function()&#123;&#125;,</div><div class="line">  method2: function()&#123;&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">定义一个有依赖的模块</div><div class="line">define([ &apos;依赖的模块&apos; ], function( $ ) &#123;</div><div class="line">   // 业务代码</div><div class="line">   return &#123;</div><div class="line">      // 供其他模块使用</div><div class="line">   &#125;</div><div class="line"> &#125;);</div><div class="line"></div><div class="line">加载模块</div><div class="line">  require( [&apos;jquery&apos;,&apos;tool&apos;] , function( $ , tool )&#123; </div><div class="line">       // 业务代码</div><div class="line">   &#125; ) ;</div><div class="line"></div><div class="line">require.config() 配置</div><div class="line">require.config(&#123;</div><div class="line">  baseUrl:&apos;/public&apos;,  //设置根路径，require里的所有路径都以此为准</div><div class="line">  paths:&#123;</div><div class="line">    jquery:&apos;./libs/jquery/jquery.min&apos;, //取别名</div><div class="line">  &#125;,</div><div class="line">  shim:&#123;</div><div class="line">    bootstrap:&#123;</div><div class="line">      deps:[&apos;jquery&apos;]  //bootstrap依赖jQuery</div><div class="line">    &#125;,</div><div class="line">    ckeditor:&#123;</div><div class="line">      exports:&apos;CKEDITOR&apos;  //ckeditor不支持模块化，向外暴露变量CKEDITOR</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><ol><li>amd和cmd的区别</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">require.js   AMD是依赖前置的，换句话说，在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块</div><div class="line">sea.js  (CMD)就近依赖： 即在代码运行时，首先是不知道依赖的，需要遍历所有的require关键字，从而找出依赖(使用字符串的正则表达式匹配)，与AMD的依赖引入方法相比，</div><div class="line">                        确实有其方便之处，但前提是以性能为代价的。</div><div class="line">1.定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。Sea.js 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以</div><div class="line">  很方便跑在 Node 环境中。</div><div class="line">2.遵循的规范不同。RequireJS 遵循 AMD（异步模块定义）规范，Sea.js 遵循 CMD （通用模块定义）规范。规范的不同，导致了两者 API 不同。Sea.js 更贴近 CommonJS Modules/1.1</div><div class="line">  和 Node Modules 规范。</div><div class="line">3.推广理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。Sea.js 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。</div><div class="line">4.对开发调试的支持有差异。Sea.js 非常关注代码的开发调试，有 nocache、debug 等用于调试的插件。RequireJS 无这方面的明显支持。</div><div class="line">5.插件机制不同。RequireJS 采取的是在源码中预留接口的形式，插件类型比较单一。Sea.js 采取的是通用事件机制，插件类型更丰富。</div></pre></td></tr></table></figure><ol><li>less</li></ol><p>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。<br>Css预处理器是一种语言，用来为css增加一些编程的特性，无需考虑浏览器的兼容问题，并且你可以在css中使用变量、简单的程序逻辑，函数等；可以让css更简洁、适应性强，代码更直观等；</p><p>LESS 是动态的样式表语言，通过简洁明了的语法定义，使编写 CSS 的工作变得非常简单，本质上，LESS 包含一套自定义的语法及一个解析器。</p><p>less 是 CSS处理器的一种，用来管理和维护CSS，并且LESS是使用Nodejs 开发的一个工具包，第三方模块<br>要使用LSSS需要安装Nodejs,环境<br>想或得Nodejs环境，只需要安装一个软件即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;技术掌握&quot;&gt;&lt;a href=&quot;#技术掌握&quot; class=&quot;headerlink&quot; title=&quot;技术掌握&quot;&gt;&lt;/a&gt;技术掌握&lt;/h1&gt;&lt;h3 id=&quot;1-HTML-和-CSS，书写语义合理、结构清晰、易于维护的页面结构，还原设计图，并处流浏览器的兼容性问题；&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博文公园(Web随心记)</title>
    <link href="http://yoursite.com/2017/09/10/Web%E9%9A%8F%E5%BF%83%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/09/10/Web随心记/</id>
    <published>2017-09-10T04:46:41.399Z</published>
    <updated>2017-09-10T07:12:21.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Welcome-to-酷K-blog"><a href="#Welcome-to-酷K-blog" class="headerlink" title="Welcome to 酷K.blog"></a>Welcome to 酷K.blog</h1><p>去交让你开心的朋友<br>去爱不会让你流泪流泪的人<br>去向自己想去的方向<br>去完成不论大小的梦想<br>生活应该是美好而又温柔的<br>你也是<br><img src="http://7xkj1z.com1.z0.glb.clouddn.com/%E5%86%99%E4%BB%A3%E7%A0%81%E5%BC%BA%E8%A1%8C%E8%A3%85%E9%80%BC.gif" alt="image"></p><h3 id="W3C标准"><a href="#W3C标准" class="headerlink" title="W3C标准"></a>W3C标准</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[W3C标准：万维网联盟的缩写。W3C不是某个标准，而是一系列标准的集合。World Wide Web Consortium万维网络联盟，</div><div class="line">是Web技术领域最具权威和影响力的国际中立性技术标准机构，到目前为止，W3C已发布了200多项web技术标准及实施指南，</div><div class="line">如：超文本标记语言（HTML）、可扩展标记语言（XML）等，有效促进了web技术的互相兼容，对互联网技术的发展和应用起</div><div class="line">到了基础性和根本性的支撑作用。</div><div class="line"></div><div class="line">对应标准也分为：</div><div class="line">              1.结构化标准语言（XHTML、XML）</div><div class="line">              2.表现标准语言（CSS）</div><div class="line">              3.行为标准（文档对象模型--W3C DOM、ECMAScript）]</div></pre></td></tr></table></figure><h2 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h2><ol><li>对象  JavaScript中万物皆对象，分为普通对象（new出来的实例对象–new Object/Array/Foo）和函数对象（Array、Object、Function…JS自带的函数对象）</li><li>原型  原型prototype是构造函数的属性，本质是对象（可理解成object的实例对象）<br>是一个对象，其他对象可以通过它实现属性的继承</li><li>原型</li><li>作用  数据共享</li><li>实现继承</li><li>原型链 实例对象和原型对象之间通过<strong>proto</strong>来联系的，这种关系叫做原型链，当访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型对象</li><li>（prototype），以及该原型对象的原型对象，层层向上搜，直到找到此属性或达到原型链的末尾（Object.prototype—-&gt;null）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Prototype与__proto__ 每个函数都有一个prototype属性和__proto__属性</div><div class="line">  当函数为普通函数时，关注的是：Prototype属性,指向自己的原型对象（foo.prototyope）</div><div class="line">  当函数为构造函数时，关注的是：__proto__,指向这个函数的构造函数的原型对象</div><div class="line">__proto__ JS在创建对象的时候（不论是普通对象还是函数对象），都有一个内置对象__proto__属性，用来指向创建它的函数对象的原型对象（prototype）</div><div class="line">Prototype 每个函数都有一个原型属性prototype指向自身的原型</div></pre></td></tr></table></figure><p>原型是一个对象，其他对象可以通过它实现属性的继承<br>原型prototype是构造函数的属性，本质是对象（可理解成object的实例对象）<br>原型继承  修改子集构造函数的prototype指向父级构造函数的实例对象<br>缺点：不能给父级构造函数传递参数<br>父级构造函数中的引用类型的数据会被子集构造函数实例共享<br>构造函数继承  目的：把父级所有的属性继承过来<br>无法继承父级构造函数原型中的成员<br>混合继承  组合原型继承和构造函数继承<br>代码有冗余，浪费内容，但其带来的好处远大于这点内存</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>定义：封闭的包裹（区域），主要指嵌套的函数，函数的嵌套形成闭包<br>通俗的说：拿到自己不该拿到的东西<br>组成：内层函数本身，内层函数所处的作用域<br>特点：闭包可以读取函数内部变量，将函数内部变量的值始终保存在内存中，保护函数内的变量不被改变。<br>作用：（1）形成隔离的封闭空间（作用域）<br>      （2）延长变量的声明周期<br>      （3）缓存数据，提高计算性能<br>缺点：延长作用域链，内存长时间得不到释放（浪费内存），尽量不用。<br>一个函数A中return 一个函数B，函数B可以访问函数A中定义的变量，此时还可以进行数据的缓存，就形成了闭包<br> 闭包用一句话说拿到你不该拿的东西，代码实现是函数里面return 一个函数，自执行函数也是闭包也叫作沙箱就是让内部变量不会污染全局；<br> 闭包的特点是闭包可以读取函数内部变量，将函数内部变量的值始终保存在内存中，保护函数内的变量不被更改；闭包的用途：缓存数据提高计算性能，</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>定义：变量和函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期；在JavaScript中有‘全局作用域’和‘局部作用域’<br>全局作用域 在代码中任何地方都能访问到的对象拥有全局作用域<br>（1）最外层函数和在最外层函数外面定义的变量拥有全局作用域<br>（2）所有未定义直接声明的变量自动声明为拥有全局作用域<br>（3）所有window对象的属性拥有全局作用域<br>局部作用域 一般只有在固定的代码片段内可以访问，例如函数内部<br>作用域链  当在一个函数的内部访问一个变量时，这个变量在这个函数内部如果是不存在的，就去这个函数的外部去找，找到了就能够使用，找不到就再往外面找，<br>直到找到这个函数所在的script标签（全局作用域），形成了作用域链<br>全局的作用域中定义的变量，可以看成是在作用域链上的最上面（0级作用域，也是最高级）</p><p>模块化开发 定义：一个模块就是实现特定功能的文件，有了模块我们就可以方便的使用别人的代码，想要什么功能就加载什么模块。模块开发需要遵循一定的规范<br>ECMAScript在低版本（ES5）是不具备模块的能力，为了实现模块化，有些牛人专门写了一些类库来弥补ECMAScript的缺陷，就又有些人定义了一些规范（AMD CMD CommonJS）<br>来加载模块，开发模块类库的人需要遵循这些规范，其中AMD 和 CMD 适用于浏览器，CommonJS适用于Nodejs（后端）<br>如果开发者遵循了 AMD 的规范来定义模块<br>define([‘’],function(){<br>     return {};<br>});<br>那么还需要一个模块加载器来加载模块，其中 requirejs（模块加载器）是可以加载AMD规范的模块<br>也可以使用 CMD 规范来定义模块<br>define(function(require, exports, module){<br>     require();//可以加载其它模块<br>     //使用 exports 和 module 将这些模块开放出去<br>     exports.sayHi = function(){//向外开放了sayHi方法};<br>     module.exports = {sayHi : sayHi};<br>});<br>使用国人开发的seajs（模块加载器）可以用来加载 CMD 规范的模块</p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>HTML5不仅仅是只作为HTML的最新版本，更重要的是它制定了web开发的一系列标准，成为第一个将web作为应用开发平台的HTML语言；<br>HTML5定义了一系列的新元素，如语义标签、智能表单，多媒体标签等，可以帮助开发者创建富互联网应用，还提供了一系列的JavaScript api：地理定位、重力感应、硬件访问等，<br>可以在浏览器内实现类原生应用，甚至结合canvas我们可以开发网页版游戏，同时结合css3的过渡、转换、动画等特性，可以极大增强用户体验，提升开发工能的可用性<br>我们日常讨论的H5是一个泛指，是：HTML5+CSS3+JavaScript等技术组合而成的一个应用开发平台<br>HTML5语法特点 更简洁<br>更宽松<br>标签语义化 所谓标签语义化就是HTML标签具备很好的可读性，可以清晰传达每个标签所要表达的意义。以便被友好的处理和解析<br>Nav（导航）、header footer section artical aside progress（进度条）<br>兼容处理  在不支持HTML5新标签的浏览器（IE8及以下）里，会将这些标签解析成行内元素（inline）对待，我们需要把其转换成块元素（block），在IE9版本以下不能正常解析这些新标签。<br>我们可以加载一个第三方JS库来解决这个问题（腻子脚本），会自动通过document.createElement(‘tagName’);创建所有HTML5标签</p><p>微数据 微数据是在如span div 标签中添加属性，让机器（如搜索引擎）识别其含义，如评论、人物信息、事件都有相应的属性，用来描述其含义，可以理解成新语义标签的一种补充</p><ol><li>HTML5 多媒体</li></ol><p>音频  <audio arc="””"></audio><br>视屏  <video src="””" controls="””"></video></p><ol><li>HTML5 DOM扩展</li></ol><p>获取元素  document.getElementByClassName(‘class’);—通过类名获取–数组<br>document.querySelector(‘各种选择器都可以’);<br>document.querySelectorAll(‘各种选择器都可以’);—数组<br>类名  Node.classList.add(‘class’);–添加class<br>Node.classList.remove(‘class’);–移除class<br>Node.classList.toggle(‘class’);–切换class<br>Node.classList.contains(‘class’);–检测是有这个class<br>自定义属性 var demo = document.querySelector(‘#demo’);<br>读取 demo.dataset[‘name’] 或者 demo.dataset.age<br>设置 demo.dataset[‘name’] = ‘web developer’</p><ol><li>HTML5 新增API</li></ol><p>网络状态  window.onLine()<br>全屏  1、Node.requestFullScreen() 开启全屏显示<br>      2、Node.cancelFullScreen()  关闭全屏显示<br>文件读取  FileReader<br>地理定位  navigator.geolocation.getCurrentPosition(successcb,errcb);<br>          navigator.geolocation.watchPosition(successcb,errcb);<br>历史管理  Window.history<br>事件监听  Oppopstate:当前进或后退时则触发，通过事件对象ev.state可以读取到存储的数据。</p><ol><li>HTML5规范新增 web存储</li></ol><p>持久化：将数据长时间保存<br>后端语言常常使用数据库来实现数据的持久化  前端也有将数据持久化的处理，以前是通过cookie简单实现，但这种方式使用起来不方便，<br>HTML5提出了新的解决方案实现数据的持久化  sessionStorage 和 localStorage<br>sessionStorage 与 localStorage 的区别  1）存储大小：sessionStorage–约 5M；  localStorage–约 20M<br>     2)生命周期：sessionStorage–关闭当前窗口； localStorage–永久存在，除非手动清空<br>     3）数据共享：sessionStorage—当前窗口； localStorage–同域下的多窗口</p><p>sessionStorage 与 session 的关系：没关系，<br>session 是会话机制的组成部分，是服务端的技术构成<br>sessionStorage 只是存储数据的一个机制，是前端的技术构成<br>cookie sessionStorage localStorage 三者都是前端的技术构成</p><h2 id="Cookie-和-session"><a href="#Cookie-和-session" class="headerlink" title="Cookie 和 session"></a>Cookie 和 session</h2><p>客户端（浏览器）和 服务器进行通信的过程称为一次会话<br>可以这样理解：一次请求+一次响应=一次会话<br>服务器 可以对应多个 客户端（浏览器）<br>如果 A 浏览器访问了 Z 服务器<br>如果 B 浏览器也访问 Z 服务器<br>为了能记住 Z 服务器明确知道是谁（A 或 B）进行访问，需要借助 cookie 和 sesion 来完成<br>当服务器与浏览器进行会话时，会将 cookie 信息以请求头的形式发送给服务器<br>利用上述特点，可以为不同的浏览器设置不同的cookie<br>例如： A 浏览器设置的 cookie 为 PHPSESSID=123abc<br>        B 浏览器设置的 cookie 为 PHPSESSID=456abc<br>当前进行会话时，A 的 cookie PHPSESSID=123abc 和 B 的 PHPSESSID=456abc<br>都会发送到 服务器， 由于 A 和 B 的 cookie 不一样，服务器就可以进行区分，进而得知是谁在访问<br>上述的 cookie 是服务器上设置 session 的同时 浏览器也就进行设置cookie</p><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><p>CSS3是CSS2的“进化”版本，在CSS2基础上，增强或新增了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。</p><ol><li>CSS3现状   </li></ol><p>浏览器支持程度差，需要加私有前缀<br>（IE=-ms-; chrome=-webkit-; firebox=-moz-; opera=-o-）<br>移动端支持优于PC端<br>不断改进中<br>应用相对广泛</p><ol><li>如何对待  </li></ol><p>坚持渐进增强的原则<br>考虑用户群体<br>遵照产品的方案</p><ol><li>颠覆性代表 </li></ol><p>过渡（transition）<br>2D转换（transform:translate() rotate() scale()）<br>transform-origin:0 20px;<br>3D转换<br>CSS3 动画 animation<br>伸缩布局（弹性盒子/弹性布局）</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this 是函数运行时自动生成的一个内部对象，只能在内部使用，但总是指向调用它的对象<br>this指向 : this到底指向谁取决于函数调用的方式<br>        1、普通函数中的this—-&gt;window<br>        2、构造函数中的this—-&gt;实例对象<br>        3、原型方法中的this—-&gt;实例对象<br>        4、对象方法中的this—-&gt;谁调用指向谁<br>        5、定时函数中的this—-&gt;window<br>        6、事件函数中的this—-&gt;绑定事件的对象<br>call/apply可以改变this的指向，使其指向第一个参数<br>什么时候需要缓存this—-this指向发生改变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Welcome-to-酷K-blog&quot;&gt;&lt;a href=&quot;#Welcome-to-酷K-blog&quot; class=&quot;headerlink&quot; title=&quot;Welcome to 酷K.blog&quot;&gt;&lt;/a&gt;Welcome to 酷K.blog&lt;/h1&gt;&lt;p&gt;去交让你开心
      
    
    </summary>
    
    
  </entry>
  
</feed>
